<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>GILT â€” Timer (prototype)</title>
<style>
  :root{
    --bg:#0B0B0D;         /* tasteful black */
    --fg:#F3EFE6;         /* warm off-white */
    --fg2:rgba(243,239,230,.72);
    --fg3:rgba(243,239,230,.46);
    --gold:#D0AB4C;       /* base gold (richer) */
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:"Neue Einstellung", system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;}
  
.wrap{
  min-height:100%;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:18px;
  box-sizing:border-box;
}
  .shell{
  position:relative;
  width:min(620px,92vw);
  user-select:none;
  -webkit-user-select:none;
  touch-action:none;

  /* NEW: stack clock + controls centered */
  display:flex;
  flex-direction:column;
  align-items:center;
}

  canvas{width:100%;height:100%;aspect-ratio:1/1;display:block;}
  .brand{
  position: fixed;
  left: 24px;
  top: 22px;
  pointer-events:none;
  display:flex;
  flex-direction:column;
  gap:6px;
  max-width:min(420px, 50vw);
  z-index:5;
}
@media (max-width: 640px){
  .brand{
    position: static;         /* stops being pinned to the corner */
    max-width: 92vw;
    margin: 14px auto 0;      /* center it and push it below the clock */
    text-align: left;
    pointer-events:none;
  }
}

  .brand .title{font-size:22px;letter-spacing:.26em;text-transform:uppercase;color:var(--fg);line-height:1;} 
  .brand .sub{font-size:12px;letter-spacing:.12em;text-transform:uppercase;color:var(--fg2);line-height:1.2;} 
  .brand .prop{font-size:12px;letter-spacing:.02em;color:var(--fg3);line-height:1.25;max-width:36ch;}
  .mini{
  width:min(760px, 92%);
  margin: 18px auto 0;

  display:grid;
  grid-template-columns: 44px 1fr 44px;  /* left btn | centered switch | right btn */
  align-items:center;
  column-gap:12px;
}

#soundBtn{ justify-self:end; } /* snug to the switch */
#pipBtn{ justify-self:start; } /* snug to the switch */

#chimeSel{
  justify-self:center;
  width:min(560px, 100%);
}

.miniBtns{
    display:flex;
  gap:10px;
  align-items:center;
}




.wrap{
  min-height:100%;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:18px;
  box-sizing:border-box;
}


@media (max-width: 640px){

  /* overall stacking: clock first, brand second */
  .wrap{
    display:flex;
    flex-direction:column;
  }
  .shell{ order: 1; }
  .brand{
    order: 2;
    position: static;
    margin: 14px auto 0;
    max-width: 92vw;
  }

  /* controls: buttons on top row, switch below, centered */
  .mini{
    width:min(520px, 92%);
    display:grid;
    grid-template-columns: 1fr 1fr;
    grid-template-areas:
      "sound pip"
      "switch switch";
    row-gap:10px;
    column-gap:12px;
  }

  #soundBtn{ grid-area:sound; justify-self:end; }
  #pipBtn{ grid-area:pip; justify-self:start; }

  #chimeSel{
  grid-area:switch;
  width: 100%;     /* âœ… fits .mini */
  min-width: 0;
  justify-self: center;
}

}




  .btn{
  width:clamp(34px, 7vw, 40px);
  height:clamp(34px, 7vw, 40px);
  border-radius:999px;
  border:1px solid rgba(243,239,230,.18);
  background:rgba(11,11,13,.72);
  color:var(--fg);
  display:grid;
  place-items:center;
  cursor:pointer;
  font-size:14px;
  padding:0;
  line-height:1;
  backdrop-filter: blur(6px);
}


  .btn:hover{border-color:rgba(243,239,230,.32);} .btn:active{transform:scale(.98);} 

 .chimeSwitch{
  position:relative;
  width: min(560px, 100%);
  height: 36px;
  border-radius:999px;
  border:1px solid rgba(243,239,230,.18);
  background:rgba(11,11,13,.72);
  backdrop-filter: blur(6px);
  display:grid;
  grid-template-columns:repeat(5,1fr);
  align-items:center;
  overflow:hidden;
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.02);
  cursor:pointer;
}



  .chimeSwitch .thumb{position:absolute;top:3px;bottom:3px;left:3px;width:calc((100% - 6px)/5);
    border-radius:999px;
    background:radial-gradient(circle at 30% 30%, rgba(255,255,255,.70), rgba(208,171,76,.88) 38%, rgba(208,171,76,1) 72%);
    box-shadow:0 8px 22px rgba(208,171,76,.14), inset 0 1px 0 rgba(255,255,255,.22);
    border:1px solid rgba(0,0,0,.22);
    transform:translateX(0);
    transition:transform 180ms cubic-bezier(.2,.8,.2,1);
    will-change:transform;
  }
  .chimeSwitch.dragging .thumb{transition:none;}
  .chimeSwitch .opt{position:relative;z-index:1;text-align:center;font-size:10px;letter-spacing:.22em;text-transform:uppercase;
    color:rgba(243,239,230,.66);user-select:none;pointer-events:auto;
  }
  .chimeSwitch .opt.sel{color:rgba(11,11,13,.88);}

  .hint{
  position:absolute;
  left:50%;
  top:50%;
  transform:translate(-50%, calc(var(--hintY, 110px) + 0px));
  font-size:12px;
  color:var(--fg3);
  letter-spacing:.02em;
  text-align:center;

  max-width:30ch;     /* <-- was 52ch; this makes it wrap into ~2 lines */
  line-height:1.35;   /* optional: nicer two-line rhythm */

  font-family:"Neue Einstellung", system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
  pointer-events:none;
}

</style>
</head>
<body>
  <div class="wrap">
  <div class="brand" aria-hidden="true">
    <div class="title">GILT</div>
    <div class="sub">Time well spent.</div>
    <br>
    <div class="prop">A simple timer that helps you with productivity and displays the importance of time.</div>
  </div>

  <div class="shell" id="shell" aria-label="Analog timer">
    <canvas id="c" width="900" height="900"></canvas>

<div class="mini">
  <button class="btn" id="soundBtn" title="Toggle ticking">ðŸ”‡</button>

  <div class="chimeSwitch" id="chimeSel" title="Finish sound" aria-label="Finish sound">
    <div class="thumb" id="chimeThumb" aria-hidden="true"></div>
    <div class="opt sel" data-i="0">NONE</div>
    <div class="opt" data-i="1">BEEP</div>
    <div class="opt" data-i="2">ALARM</div>
    <div class="opt" data-i="3">CHIME</div>
    <div class="opt" data-i="4">BIRDS</div>
  </div>

  <button class="btn" id="pipBtn" title="Mini window (if supported)">â§‰</button>
</div>


    <div class="hint" id="hint">Drag dial hand to set the timer, release to start</div>
  </div>
</div>


<script>
(() => {
  const canvas = document.getElementById('c');
  const shell  = document.getElementById('shell');
  const ctx    = canvas.getContext('2d');

  const styles = getComputedStyle(document.documentElement);
  const GOLD_BASE = (styles.getPropertyValue('--gold').trim() || '#C6A14A');
  const FG = (styles.getPropertyValue('--fg').trim() || '#F3EFE6');
  const BG = (styles.getPropertyValue('--bg').trim() || '#0B0B0D');

  const TAU = Math.PI*2;
  const angle0 = -Math.PI/2; // 0 at top
  const MAX_MIN = 60;

  let totalSec = 0;
  let remainingSec = 0;
  let running = false;

  let runStartT = 0;          // performance.now() when countdown started/resumed
  let runStartRemaining = 0;  // remainingSec at start/resume

  let finishWatch = null;     // NEW: background watcher so finish triggers even when tab is hidden

  let knobDown = false;

  // physical-ish dial state
  let dialArcMin = 0;
  let dialArcMinTarget = 0;      // smoothed/inertial target
  let dialArcMinTargetRaw = 0;   // immediate pointer target (no inertia)
  let dialTargetVel = 0;         // target inertia (min/s)
  let dialVel = 0;

  let dragging = false;
  let dragStartMin = 0;
  let dragStartAngle = 0; // (legacy)
  let dragAccum = 0;      // accumulated angle while dragging
  let dragLastAngle = 0;  // last pointer angle for unwrapped motion
  let dragVelMinPerSec = 0; // smoothed drag velocity for subtle "throw"
  let lastDragT = performance.now();
  let lastPointerMove = performance.now(); // used to detect "hold still" while dragging

  // Reset animation (winds back mechanically)
  let resetting = false;

  // commit after settle (so release can coast smoothly)
  let commitPending = false;
  let commitDeadline = 0;
  let autoStartPending = false; // start countdown once the dial settles (analog behavior)

  let lastFrame = performance.now();

  // audio
  // - ticking: swiss-watch timbre at 1 motif/sec (present but not distracting)
  // - alarm: art-deco chime (louder, elegant), plays up to 60s or until knob press
  let audioOn = false;
  let audioCtx = null;
  let tickInterval = null;

  let alarmActive = false;
  let alarmInterval = null;
  let alarmStopTimeout = null;

  // Finish chime selection: 0=mechanical carillon, 1=melodic luxury, 2=morning bird
  let chimeMode = 0;

// Bird MP3s (two files shipped with the site; alternated per TIMER completion)
const BIRD_FILES = [
  'Cozumel Wren Timer.mp3',
  'Rose Throated Tanager Timer.mp3'
];

// Use plain HTMLAudio so it's "just the file" (no synth, no filters, no random starts)
const birdAudios = BIRD_FILES.map((src) => {
  const a = new Audio(src);
  a.preload = 'auto';
  a.volume = 1.0;     // loud as browser allows
  a.loop = false;
  return a;
});

let birdNext = 0;        // toggles only when a timer completes
let birdChosen = 0;      // locked for the current alarm session
let birdStopTimeout = null;

function stopBirdAudio(){
  for (const a of birdAudios){
    try{
      a.pause();
      a.currentTime = 0;
      a.loop = false;
      a.volume = 1.0;
    }catch(e){}
  }
  if (birdStopTimeout){
    clearTimeout(birdStopTimeout);
    birdStopTimeout = null;
  }
}

// Keep this name because your code already calls it
async function ensureBirdBuffersLoaded(){
  // Warm-load files; no AudioContext needed
  try{
    for (const a of birdAudios){
      a.volume = 1.0;
      a.load();
    }
  }catch(e){}
}

//const CHIME_NAMES = ['MECH','MELODY','BIRD'];



  // Gain tuning
  // (We keep the tick polite; the alarm is clearly audible but "luxury"â€”rounded + reverbed.)
  const TICK_VOL = 0.125; // keep tick polite
  // NOTE: Alarm volume is intentionally high; users can always mute ðŸ”‡.
  const ALARM_VOL = 1.0;  // loud as possible (compressor prevents clipping)

  // Audio bus chain (simple "luxury" polish): dry + subtle convolution reverb + gentle compressor.
  let bus = null;
  let dryGain = null;
  let wetGain = null;
  let convolver = null;
  let compressor = null;
  let masterGain = null;

  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function normAngle(a){ a%=TAU; if(a<0)a+=TAU; return a; }

  function signedAngleDelta(a, b){
    // signed delta from a -> b in [-pi, pi]
    let d = (b - a) % TAU;
    if (d > Math.PI) d -= TAU;
    if (d < -Math.PI) d += TAU;
    return d;
  }

  function pointerAngle(clientX, clientY){
    const r = canvas.getBoundingClientRect();
    const x = (clientX - r.left) / r.width  * canvas.width;
    const y = (clientY - r.top)  / r.height * canvas.height;
    const cx = canvas.width/2, cy = canvas.height/2;
    // Standard angle: 0 at +x, positive CCW
    const a = Math.atan2(y - cy, x - cx);
    return normAngle(a);
  }

  function withinKnob(clientX, clientY){
    const r = canvas.getBoundingClientRect();
    const x = (clientX - r.left) / r.width  * canvas.width;
    const y = (clientY - r.top)  / r.height * canvas.height;
    const cx = canvas.width/2, cy = canvas.height/2;
    return Math.hypot(x-cx, y-cy) <= canvas.width*0.11;
  }

  function withinRing(clientX, clientY){
    const r = canvas.getBoundingClientRect();
    const x = (clientX - r.left) / r.width  * canvas.width;
    const y = (clientY - r.top)  / r.height * canvas.height;
    const cx = canvas.width/2, cy = canvas.height/2;
    const d = Math.hypot(x-cx, y-cy);
    // Slightly more forgiving for fingers / touch
    const outer = canvas.width*0.47;
    const inner = canvas.width*0.18;
    return d >= inner && d <= outer;
  }

  function setHint(){
    const h = document.getElementById('hint');
    const wheelWinding = performance.now() < (wheelActiveUntil || 0);

    // Primary instruction states
    if (dragging || wheelWinding){
      h.textContent = 'Drag dial hand to set the timer, release to start';
      return;
    }

    if (alarmActive){
      h.textContent = "Time's up â€” press the knob to stop the alarm";
      return;
    }

    if (remainingSec > 0){
      h.textContent = 'Press the knob to pause, double press to reset';
      return;
    }

    h.textContent = 'Drag dial hand to set the timer, release to start';
  }

  let tickTimeout = null;
  function stopTicking(){
    if (tickInterval){ clearInterval(tickInterval); tickInterval=null; }
    if (tickTimeout){ clearTimeout(tickTimeout); tickTimeout=null; }
  }
  function stopAlarm(){
  alarmActive = false;

  // âœ… stop any playing bird MP3 alarm
  stopBirdAudio();

  if (alarmInterval){ clearInterval(alarmInterval); alarmInterval = null; }
  if (alarmStopTimeout){ clearTimeout(alarmStopTimeout); alarmStopTimeout = null; }
  setHint();
}

  function ensureAudio(){
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (!bus) setupAudioChain();
  }

  function setupAudioChain(){
    // One shared bus so alarm/tick share the same "room" and loudness control.
    bus = audioCtx.createGain();
    bus.gain.value = 1.0;

    // Dry/wet split
    dryGain = audioCtx.createGain();
    dryGain.gain.value = 0.92;

    wetGain = audioCtx.createGain();
    wetGain.gain.value = 0.18; // keep loud + classy (less wash) // subtle, classy room

    convolver = audioCtx.createConvolver();
    convolver.buffer = makeImpulseResponse(1.25, 2.2);

    compressor = audioCtx.createDynamicsCompressor();
    compressor.threshold.setValueAtTime(-18, audioCtx.currentTime);
    compressor.knee.setValueAtTime(10, audioCtx.currentTime);
    compressor.ratio.setValueAtTime(3.2, audioCtx.currentTime);
    compressor.attack.setValueAtTime(0.004, audioCtx.currentTime);
    compressor.release.setValueAtTime(0.22, audioCtx.currentTime);

    masterGain = audioCtx.createGain();
    masterGain.gain.value = 1.0;

    // bus -> dry -> compressor -> master -> destination
    bus.connect(dryGain).connect(compressor).connect(masterGain).connect(audioCtx.destination);

    // bus -> convolver -> wet -> compressor -> master -> destination
    bus.connect(convolver).connect(wetGain).connect(compressor);
  }

  function makeImpulseResponse(seconds, decay){
    const rate = audioCtx.sampleRate;
    const length = Math.max(1, Math.floor(rate * seconds));
    const impulse = audioCtx.createBuffer(2, length, rate);

    for (let ch = 0; ch < 2; ch++){
      const data = impulse.getChannelData(ch);
      for (let i = 0; i < length; i++){
        const t = i / length;
        // Exponentially decaying noise; slightly darker tail
        const n = (Math.random()*2 - 1);
        data[i] = n * Math.pow(1 - t, decay) * 0.55;
      }
    }
    return impulse;
  }
  function swissTickOnce(){
    // (Timbre) Swiss-watch-ish escapement click.

    if (!audioOn || !audioCtx) return;

    // Swiss watch feel: fast, crisp, slightly metallic, very short.
    // We simulate a tiny double-impulse (escapement) per beat.
    const t0 = audioCtx.currentTime;

    function click(at){
      const dur = 0.018;
      const buf = audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate*dur), audioCtx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i=0;i<data.length;i++){
        const x = (Math.random()*2 - 1);
        // very short decaying noise, crisp
        data[i] = x * Math.exp(-i/(data.length*0.18));
      }
      const src = audioCtx.createBufferSource();
      src.buffer = buf;

      const bp = audioCtx.createBiquadFilter();
      bp.type = 'bandpass';
      bp.frequency.setValueAtTime(3200, at);
      bp.Q.setValueAtTime(14, at);

      const lp = audioCtx.createBiquadFilter();
      lp.type = 'lowpass';
      lp.frequency.setValueAtTime(7800, at);
      lp.Q.setValueAtTime(0.7, at);

      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0.00001, at);
      g.gain.exponentialRampToValueAtTime(TICK_VOL, at+0.002);
      g.gain.exponentialRampToValueAtTime(0.00001, at+0.022);

      // tiny metallic partial
      const o = audioCtx.createOscillator();
      o.type = 'sine';
      o.frequency.setValueAtTime(4200, at);
      const og = audioCtx.createGain();
      og.gain.setValueAtTime(0.00001, at);
      og.gain.exponentialRampToValueAtTime(TICK_VOL*0.22, at+0.003);
      og.gain.exponentialRampToValueAtTime(0.00001, at+0.025);

      src.connect(bp).connect(lp).connect(g).connect(bus);
      o.connect(og).connect(bus);

      src.start(at);
      src.stop(at + dur);
      o.start(at);
      o.stop(at + 0.03);
    }

    click(t0);
    click(t0 + 0.012);
  }

  function decoChimeStrike(variant=0){
    if (!audioCtx) return;


    const t = audioCtx.currentTime;

    // TRUE mechanical feel = mechanism noises + chime bars.
    // We add: ratchet burst (gear train), striker clicks, low case thunk, then bar resonances.

    // Pitch sets for the bars (rotated so it doesn't feel looped)
    const sets = [
      [622.25, 932.33, 1244.51, 831.61],   // Eb5 Bb5 Eb6 Ab5
      [587.33, 880.00, 1174.66, 783.99],   // D5 A5 D6 G5
      [659.25, 987.77, 1318.51, 880.00],   // E5 B5 E6 A5
    ];
    const tones = sets[variant % sets.length];

    // Master envelope for the entire mechanism burst
    const sum = audioCtx.createGain();
    sum.gain.setValueAtTime(0.00001, t);
    sum.gain.exponentialRampToValueAtTime(ALARM_VOL, t+0.018);
    sum.gain.exponentialRampToValueAtTime(0.00001, t+2.10);

    // Slightly darker, more "hardware"
    const lp = audioCtx.createBiquadFilter();
    lp.type = 'lowpass';
    lp.frequency.setValueAtTime(5200, t);
    lp.Q.setValueAtTime(0.7, t);

    const hs = audioCtx.createBiquadFilter();
    hs.type = 'highshelf';
    hs.frequency.setValueAtTime(4200, t);
    hs.gain.setValueAtTime(-7.5, t);

    sum.connect(lp).connect(hs).connect(bus);

    // --- Ratchet / gear train (short burst) ---
    (function ratchetBurst(){
      const dur = 0.22;
      const buf = audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate*dur), audioCtx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i=0;i<data.length;i++){
        const x = (Math.random()*2-1);
        // Impulses -> ratchety texture
        const p = (i % 1100) < 90 ? 1 : 0;
        data[i] = (x*0.18 + p*0.85) * Math.exp(-i/(data.length*0.22));
      }
      const src = audioCtx.createBufferSource();
      src.buffer = buf;

      const bp = audioCtx.createBiquadFilter();
      bp.type = 'bandpass';
      bp.frequency.setValueAtTime(1200, t);
      bp.Q.setValueAtTime(2.2, t);

      // Comb-ish metallic cavity
      const delay = audioCtx.createDelay();
      delay.delayTime.setValueAtTime(0.010, t);
      const fb = audioCtx.createGain();
      fb.gain.setValueAtTime(0.42, t);
      delay.connect(fb).connect(delay);

      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0.00001, t);
      g.gain.exponentialRampToValueAtTime(ALARM_VOL*0.20, t+0.010);
      g.gain.exponentialRampToValueAtTime(0.00001, t+0.24);

      src.connect(bp).connect(delay).connect(g).connect(sum);
      src.start(t);
      src.stop(t+dur);
    })();

    // Low case thunk (very short)
    (function caseThunk(){
      const o = audioCtx.createOscillator();
      o.type = 'sine';
      o.frequency.setValueAtTime(92, t);
      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0.00001, t);
      g.gain.exponentialRampToValueAtTime(ALARM_VOL*0.05, t+0.010);
      g.gain.exponentialRampToValueAtTime(0.00001, t+0.12);
      o.connect(g).connect(sum);
      o.start(t);
      o.stop(t+0.15);
    })();

    function barTone(freq, when, amp){
      // Inharmonic partials typical of chime bars, with subtle chorus
      const partials = [1.00, 2.76, 5.40, 7.15];
      const detunes = [-6, +6];

      for (const cents of detunes){
        for (let i=0;i<partials.length;i++){
          const o = audioCtx.createOscillator();
          o.type = (i===0) ? 'triangle' : 'sine';
          o.frequency.setValueAtTime(freq*partials[i], when);
          o.detune.setValueAtTime(cents, when);

          const g = audioCtx.createGain();
          g.gain.setValueAtTime(0.00001, when);
          g.gain.exponentialRampToValueAtTime((amp/(i+1))*0.30, when+0.020);
          g.gain.exponentialRampToValueAtTime(0.00001, when+1.75);

          o.connect(g).connect(sum);
          o.start(when);
          o.stop(when+2.00);
        }
      }

      // Striker click (mechanical)
      const click = audioCtx.createBufferSource();
      const dur = 0.020;
      const buf = audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate*dur), audioCtx.sampleRate);
      const d = buf.getChannelData(0);
      for (let i=0;i<d.length;i++) d[i] = (Math.random()*2-1) * Math.exp(-i/(d.length*0.18));
      click.buffer = buf;

      const bp = audioCtx.createBiquadFilter();
      bp.type = 'bandpass';
      bp.frequency.setValueAtTime(2000, when);
      bp.Q.setValueAtTime(7.5, when);

      const cg = audioCtx.createGain();
      cg.gain.setValueAtTime(0.00001, when);
      cg.gain.exponentialRampToValueAtTime(ALARM_VOL*0.10, when+0.006);
      cg.gain.exponentialRampToValueAtTime(0.00001, when+0.060);

      click.connect(bp).connect(cg).connect(sum);
      click.start(when);
      click.stop(when+dur);
    }

    // Mechanical strike sequence (feels like a real train)
    const seq = [0.10, 0.34, 0.60, 0.88];
    for (let i=0;i<seq.length;i++){
      barTone(tones[i], t + seq[i], 1.0 - i*0.10);
    }
  }

  // Non-repetitive luxury "watch" melody: generated motifs with variation.
  // Goal: never feels like a ringtone; feels like an expensive object.
  let lastMelodyId = -1;
  // Luxury mechanical "watch chime" melody
  // - Bell-like tones that could plausibly come from watch/clock chime bars
  // - Rhythmic, elegant, not ringtone-y
  // - Generates a slightly different phrase each time (avoids obvious repetition)
  let lastMelodySig = '';
  function melodicChimeMotif(){
    if (!audioCtx) return;

    const t = audioCtx.currentTime;

    // A tasteful pitch set (close intervals, no pop-song hooks)
    // Think: high-end minute repeater vibe.
    const base = 440 * Math.pow(2, (Math.random()*4 - 2)/12); // small transposition
    const scale = [0, 3, 7, 10, 14]; // minor-ish, open but not happy
    const freqs = scale.map(semi => base * Math.pow(2, semi/12));

    // Rhythm template (seconds) â€” not too repetitive
    const patterns = [
      [0.00, 0.22, 0.46, 0.78, 1.08, 1.36],
      [0.00, 0.28, 0.56, 0.86, 1.18, 1.48],
      [0.00, 0.20, 0.44, 0.64, 0.96, 1.24, 1.54],
      [0.00, 0.30, 0.60, 0.90, 1.22, 1.52]
    ];

    let pickP = Math.floor(Math.random()*patterns.length);
    const times = patterns[pickP].map(x => x + (Math.random()*0.010 - 0.005));

    // Build a phrase with gentle motion (avoid repetitive up-up-up)
    let idx = Math.floor(Math.random()*freqs.length);
    const notes = [];
    for (let i=0;i<times.length;i++){
      const step = (Math.random()<0.55) ? (Math.random()<0.5? -1 : 1) : (Math.random()<0.5? -2 : 2);
      idx = clamp(idx + step, 0, freqs.length-1);
      notes.push(freqs[idx]);
    }

    // Signature to avoid obvious repetition
    const sig = notes.map(n=>Math.round(Math.log2(n/base)*1200)).join(',') + '|' + times.length;
    if (sig === lastMelodySig){
      // Nudge last note to force variation
      notes[notes.length-1] = freqs[clamp(idx + (Math.random()<0.5?-1:1), 0, freqs.length-1)];
    }
    lastMelodySig = sig;

    // Mix node (loud, polished)
    const sum = audioCtx.createGain();
    sum.gain.setValueAtTime(0.00001, t);
    sum.gain.exponentialRampToValueAtTime(ALARM_VOL*0.95, t+0.014);
    sum.gain.exponentialRampToValueAtTime(0.00001, t+2.60);

    // Slightly bright but never piercing
    const lp = audioCtx.createBiquadFilter();
    lp.type = 'lowpass';
    lp.frequency.setValueAtTime(6200, t);
    lp.Q.setValueAtTime(0.85, t);

    const hs = audioCtx.createBiquadFilter();
    hs.type = 'highshelf';
    hs.frequency.setValueAtTime(5200, t);
    hs.gain.setValueAtTime(-6.5, t);

    sum.connect(lp).connect(hs).connect(bus);

    function chimeBar(freq, when, strength){
      // Inharmonic partials typical of metal bars (minute repeater-esque)
      const partials = [1.00, 2.74, 5.41, 7.13];
      const det = [-4, +4];

      for (const cents of det){
        for (let i=0;i<partials.length;i++){
          const o = audioCtx.createOscillator();
          o.type = (i===0) ? 'triangle' : 'sine';
          o.frequency.setValueAtTime(freq*partials[i], when);
          o.detune.setValueAtTime(cents, when);

          const g = audioCtx.createGain();
          g.gain.setValueAtTime(0.00001, when);
          g.gain.exponentialRampToValueAtTime((strength/(i+1))*0.24, when+0.016);
          g.gain.exponentialRampToValueAtTime(0.00001, when+1.90);

          o.connect(g).connect(sum);
          o.start(when);
          o.stop(when+2.05);
        }
      }

      // Hammer/striker click (soft but present)
      const dur = 0.020;
      const buf = audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate*dur), audioCtx.sampleRate);
      const d = buf.getChannelData(0);
      for (let i=0;i<d.length;i++) d[i] = (Math.random()*2-1) * Math.exp(-i/(d.length*0.20));
      const n = audioCtx.createBufferSource();
      n.buffer = buf;

      const bp = audioCtx.createBiquadFilter();
      bp.type = 'bandpass';
      bp.frequency.setValueAtTime(1900, when);
      bp.Q.setValueAtTime(8.0, when);

      const ng = audioCtx.createGain();
      ng.gain.setValueAtTime(0.00001, when);
      ng.gain.exponentialRampToValueAtTime(ALARM_VOL*0.12, when+0.006);
      ng.gain.exponentialRampToValueAtTime(0.00001, when+0.060);

      n.connect(bp).connect(ng).connect(sum);
      n.start(when);
      n.stop(when+dur);
    }

    // Compose
    for (let i=0;i<times.length;i++){
      const when = t + times[i];
      const strength = 1.0 - i*0.06;
      const cents = (Math.random()*4 - 2); // micro drift
      const f = notes[i] * Math.pow(2, cents/1200);
      chimeBar(f, when, strength);
    }
  }

  // Bird: more natural (still synthesized), less "beep".
  // We model a short bird phrase: FM + vibrato + breathy noise, randomized.
  function birdMorningMotif(){
    if (!audioOn || !audioCtx) return;
    const t = audioCtx.currentTime;

    // Prefer the two built-in bird recordings (alternating each chime).
if (birdBuffers[0] && birdBuffers[1]){
  const buf = birdBuffers[birdChosen];

  const src = audioCtx.createBufferSource();
  src.buffer = buf;

  // Pick a random start window so it doesn't feel looped
  const maxStart = Math.max(0, buf.duration - 1.6);
  const startAt = (maxStart > 0) ? Math.random()*maxStart : 0;

  const g = audioCtx.createGain();
  g.gain.setValueAtTime(0.00001, t);
  g.gain.exponentialRampToValueAtTime(ALARM_VOL*1.00, t+0.020);
  g.gain.exponentialRampToValueAtTime(0.00001, t+1.60);

  // Tame harshness (birds can be piercing)
  const lp = audioCtx.createBiquadFilter();
  lp.type = 'lowpass';
  lp.frequency.setValueAtTime(7400, t);
  lp.Q.setValueAtTime(0.7, t);

  const hs = audioCtx.createBiquadFilter();
  hs.type = 'highshelf';
  hs.frequency.setValueAtTime(5600, t);
  hs.gain.setValueAtTime(-5.5, t);

  src.connect(lp).connect(hs).connect(g).connect(bus);
  src.start(t, startAt);
  src.stop(t + 1.6);
  return;
}


    // Fallback synthesized bird (kept gentle) if no recording was provided.
    function birdChirp(at, baseHz){
      const dur = 0.14 + Math.random()*0.07;

      const o = audioCtx.createOscillator();
      o.type = 'sine';

      const vib = audioCtx.createOscillator();
      vib.type = 'sine';
      vib.frequency.setValueAtTime(12 + Math.random()*6, at);
      const vibG = audioCtx.createGain();
      vibG.gain.setValueAtTime(12 + Math.random()*8, at);
      vib.connect(vibG).connect(o.frequency);

      const f0 = baseHz * (0.90 + Math.random()*0.06);
      const f1 = baseHz * (1.24 + Math.random()*0.10);
      o.frequency.setValueAtTime(f0, at);
      o.frequency.exponentialRampToValueAtTime(f1, at + dur*0.55);
      o.frequency.exponentialRampToValueAtTime(f0*0.96, at + dur);

      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0.00001, at);
      g.gain.exponentialRampToValueAtTime(ALARM_VOL*0.35, at+0.012);
      g.gain.exponentialRampToValueAtTime(0.00001, at+dur);

      o.connect(g).connect(bus);
      o.start(at);
      vib.start(at);
      o.stop(at+dur);
      vib.stop(at+dur);
    }

    const base = 1350 + Math.random()*520;
    birdChirp(t+0.00, base);
    birdChirp(t+0.22 + Math.random()*0.10, base*0.94);
    if (Math.random() < 0.40) birdChirp(t+0.44 + Math.random()*0.12, base*1.06);
  }

 function decoBeepMotif(variant){
  // short, tasteful mechanical repeating â€œbeepâ€ (double strike)
  // (uses your existing premium chime strike but cropped by rhythm)
  decoChimeStrike(variant);
}

function alarmBellMotif(variant){
  // aggressive, wake-up alarm: metallic â€œbell clustersâ€, loud + annoying
  if (!audioCtx || !bus) return;
  const t = audioCtx.currentTime + 0.01;

  const freqs = [740, 880, 660, 990];
  for (let i=0;i<3;i++){
    const at = t + i*0.085;

    const o = audioCtx.createOscillator();
    o.type = 'square';
    o.frequency.setValueAtTime(freqs[(i + variant) % freqs.length], at);

    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0.00001, at);
    g.gain.exponentialRampToValueAtTime(ALARM_VOL*0.95, at+0.006);
    g.gain.exponentialRampToValueAtTime(0.00001, at+0.20);

    o.connect(g).connect(bus);
    o.start(at);
    o.stop(at+0.22);
  }
}

function playSelectedAlarmMotif(variant){
  if (chimeMode === 1) return decoBeepMotif(variant);   // BEEP
  if (chimeMode === 2) return alarmBellMotif(variant);  // ALARM
  if (chimeMode === 3) return melodicChimeMotif();      // CHIME (your luxury phrase)
}


function startAlarm(){
  // NONE = no finish sound
  if (chimeMode === 0) return;

  // alarms should not depend on ticking mute
  ensureAudio();
  stopTicking();
  stopAlarm();

  alarmActive = true;
  setHint();

  // BIRDS (mode 4) = play ONE mp3 continuously for 2 minutes
  if (chimeMode === 4){
    ensureBirdBuffersLoaded();

    const a = birdAudios[birdChosen];
    try{
      a.currentTime = 0;
      a.volume = 1.0;
      a.loop = true;
      a.play().catch(()=>{});
    }catch(e){}

    birdStopTimeout = setTimeout(() => stopAlarm(), 120_000);
    return;
  }

  // BEEP / ALARM / CHIME (WebAudio motifs)
  try{ audioCtx.resume(); }catch(e){}

  let v = 0;
  const motif = () => {
    if (!alarmActive) return;
    playSelectedAlarmMotif(v++);
  };

  motif();

let intervalMs = 2200; // CHIME default
if (chimeMode === 1) intervalMs = 2400; // âœ… BEEP cadence = old MECH cadence
if (chimeMode === 2) intervalMs = 650;  // ALARM stays aggressive
intervalMs += (Math.random()*220 - 110); // âœ… old-style jitter


  alarmInterval = setInterval(motif, intervalMs);
  alarmStopTimeout = setTimeout(()=> stopAlarm(), 60_000);
}



  function startTicking(){
    if (!audioOn) return;
    ensureAudio();
    stopTicking();

    // You want 1 motif / second (less busy than a true watch, but still "alive").
    // We keep the Swiss escapement TIMBRE and fire once per second with a tiny drift.

    const loop = () => {
      if (!running) return;
      swissTickOnce();
      const jitter = (Math.random()*26 - 13); // subtle mechanical drift
      tickTimeout = setTimeout(loop, Math.max(860, 1000 + jitter));
    };

    swissTickOnce();
    tickTimeout = setTimeout(loop, 1000);
  }

  function commitDial(){
  // âœ… NEW: if an alarm is currently ringing, committing a new time cancels it immediately
  stopAlarm();

  dialArcMin = clamp(dialArcMin, 0, MAX_MIN);

  const newRemaining = Math.round(dialArcMin * 60);

  totalSec = newRemaining;
  remainingSec = newRemaining;

  runStartT = performance.now();
  runStartRemaining = remainingSec;
}

  function stopFinishWatch(){
  if (finishWatch){
    clearInterval(finishWatch);
    finishWatch = null;
  }
}

function onTimerFinished(){
  if (!running) return;

  remainingSec = 0;
  running = false;

  // âœ… NEW: force dial visuals to 0 immediately (even if rAF is paused in background)
  dialArcMin = 0;
  dialArcMinTarget = 0;
  dialArcMinTargetRaw = 0;
  dialTargetVel = 0;
  dialVel = 0;

  stopFinishWatch();
  stopTicking();

ensureAudio();
try{ audioCtx.resume(); }catch(e){}
startAlarm();


  setHint();
}


function startFinishWatch(){
  if (finishWatch) return;

  finishWatch = setInterval(() => {
    if (!running) return;
    if (resetting) return;

    const now = performance.now();
    const wheelWinding = now < wheelActiveUntil;
    const interacting = dragging || wheelWinding || commitPending;
    if (interacting) return;

    const elapsed = (performance.now() - runStartT) / 1000;
    const rem = runStartRemaining - elapsed;

    if (rem <= 0){
      onTimerFinished();
    }
  }, 500); // 500ms is fine; in background it will be clamped but still fires
}



  function resetAll(){
    stopAlarm();
    // Always clear any in-flight interaction so input never gets "stuck" after reset.
    if (pointerId !== null){
      try{ canvas.releasePointerCapture(pointerId); }catch(e){}
    }
    pointerId = null;
    dragging = false;
    canvas.style.cursor = 'grab';

    // Clear wheel/trackpad state
    wheelImpulse = 0;
    wheelActiveUntil = 0;
    wheelPrecisionUntil = 0;

    running = false;
    totalSec = 0;
    remainingSec = 0;

    dialArcMin = 0;
    dialArcMinTarget = 0;
    dialArcMinTargetRaw = 0;
    dialTargetVel = 0;
    dialVel = 0;

    dragStartMin = 0;
    dragAccum = 0;
    dragVelMinPerSec = 0;

    commitPending = false;
    autoStartPending = false;
    resetting = false;

    stopTicking();
    stopFinishWatch();
    setHint();
  }

  // Mechanical reset: wind the dial back quickly (but plausibly), then finalize to zero.
  function startReset(){
    stopAlarm();
    // Cancel any active drag/capture so we don't get stuck after reset.
    if (pointerId !== null){
      try{ canvas.releasePointerCapture(pointerId); }catch(e){}
    }
    pointerId = null;
    dragging = false;
    canvas.style.cursor = 'grab';

    // Clear wheel/trackpad state immediately
    wheelImpulse = 0;
    wheelActiveUntil = 0;
    wheelPrecisionUntil = 0;

    running = false;
    stopTicking();
    commitPending = false;
    autoStartPending = false;

    resetting = true;
    dialArcMinTargetRaw = 0;
    dialArcMinTarget = dialArcMin; // start from current; physics will pull it down
    dialTargetVel = 0;

    // Give it a strong "rewind" kick (clamped so it feels possible)
    const kick = Math.max(8, dialArcMin * 14);
    dialVel = clamp(-kick, -26, -8);

    // Reset drag kinematics (so the next drag starts clean)
    dragAccum = 0;
    dragVelMinPerSec = 0;

    setHint();
  }

function toggleRun(){
  if (remainingSec <= 0) return;
  // If alarm is active, knob press should have stopped it before this.
  running = !running;

  if (running){
    runStartT = performance.now();
    runStartRemaining = remainingSec;

    startTicking();
    startFinishWatch();
  } else {
    stopTicking();
    stopFinishWatch();
  }

  setHint();
}


  document.getElementById('soundBtn').addEventListener('click', async () => {
    audioOn = !audioOn; // ticking only
    document.getElementById('soundBtn').textContent = audioOn ? 'ðŸ”Š' : 'ðŸ”‡';

    if (audioOn){
      ensureAudio();
      try{ await audioCtx.resume(); }catch(e){}
      if (running) startTicking();
    } else {
      stopTicking();
    }
  });


  // Picture-in-Picture / mini-window
  // Goal: freely resizable mini view, readable down to 120px.
  // Notes:
  // - Video PiP (requestPictureInPicture) is usually resizable by the user, but browsers control min size.
  // - Document PiP / popout can be clamped to a 120px minimum.
  const MIN_PIP = 120;

  // Prefer Video PiP from canvas.captureStream (widely supported).
  let pipVideo = null;
  async function ensurePipVideo(){
    if (pipVideo) return pipVideo;
    pipVideo = document.createElement('video');
    pipVideo.muted = true;
    pipVideo.playsInline = true;
    pipVideo.style.position = 'fixed';
    pipVideo.style.left = '-9999px';
    pipVideo.style.top = '-9999px';
    // Higher internal resolution keeps it crisp when resized small.
    pipVideo.width = 360;
    pipVideo.height = 360;
    document.body.appendChild(pipVideo);
    if (canvas.captureStream){
      pipVideo.srcObject = canvas.captureStream(30);
      try{ await pipVideo.play(); }catch(e){}
    }
    return pipVideo;
  }

  function clampWindowMinSize(win){
    // Try to enforce a 120px minimum for windows we control (Document PiP / popout).
    try{
      const w = Math.max(MIN_PIP, win.innerWidth || 0);
      const h = Math.max(MIN_PIP, win.innerHeight || 0);
      if ((win.innerWidth || 0) < MIN_PIP || (win.innerHeight || 0) < MIN_PIP){
        // Some browsers may block resizeTo; safe to try.
        win.resizeTo(w, h);
      }
    } catch(e){}
  }

  document.getElementById('pipBtn').addEventListener('click', async () => {
    // 1) Video PiP (user-resizable; min size is browser-controlled)
    try{
      const v = await ensurePipVideo();
      if (document.pictureInPictureElement){
        await document.exitPictureInPicture();
        return;
      }
      if (v && v.requestPictureInPicture){
        await v.requestPictureInPicture();
        // Can't force min size here; browser decides. We just ensure it's crisp down small.
        return;
      }
    } catch(e){}

    // 2) Document PiP (Chrome experimental) â€” clamp min size to 120px
    if ('documentPictureInPicture' in window){
      try{
        const pipWindow = await window.documentPictureInPicture.requestWindow({width: 240, height: 240});
        pipWindow.document.documentElement.style.height = '100%';
        pipWindow.document.body.style.margin = '0';
        pipWindow.document.body.style.height = '100%';
        pipWindow.document.body.style.background = '#fff';
        pipWindow.document.body.style.minWidth = MIN_PIP + 'px';
        pipWindow.document.body.style.minHeight = MIN_PIP + 'px';

        const c2 = document.createElement('canvas');
        c2.width = 360; c2.height = 360;
        c2.style.width = '100%';
        c2.style.height = '100%';
        c2.style.minWidth = MIN_PIP + 'px';
        c2.style.minHeight = MIN_PIP + 'px';
        pipWindow.document.body.appendChild(c2);

        const pipCtx = c2.getContext('2d');
        function mirror(){
          try{ pipCtx.clearRect(0,0,c2.width,c2.height); pipCtx.drawImage(canvas,0,0,c2.width,c2.height); }catch(e){}
          if (!pipWindow.closed) requestAnimationFrame(mirror);
        }
        mirror();

        pipWindow.addEventListener('resize', () => clampWindowMinSize(pipWindow));
        clampWindowMinSize(pipWindow);
        return;
      } catch(e){}
    }

    // 3) Popout fallback â€” freely resizable; clamp min size to 120px
    const w = window.open(location.href, 'gilt_popout', 'width=320,height=320,resizable=1,menubar=0,toolbar=0,location=0,status=0');
    if (!w){
      alert('Pop-up blocked. Allow pop-ups for this site to use a resizable mini window.');
      return;
    }
    // Best-effort min clamp (browser may restrict).
    w.addEventListener?.('resize', () => clampWindowMinSize(w));
  });
// --- Chime selector (slide switch: 5 options) ---
const chSel = document.getElementById('chimeSel');
const chThumb = document.getElementById('chimeThumb');

const CHIME_NAMES = ['NONE','BEEP','ALARM','CHIME','BIRDS'];
const CHIME_COUNT = CHIME_NAMES.length;

// IMPORTANT: chimeMode must exist globally (keep your existing one)
function updateChimeUI(dragIndex=null){
  const r = chSel.getBoundingClientRect();
  const segW = (r.width - 6) / CHIME_COUNT; // matches your 3px+3px padding

  // dragIndex is a float, we map to continuous motion but keep in range
  const xIdx = (dragIndex === null) ? chimeMode : clamp(dragIndex, 0, CHIME_COUNT - 1);
  const xPx = Math.round(xIdx * segW); // pixel snap removes visual jitter
  chThumb.style.transform = `translateX(${xPx}px)`;

  const opts = chSel.querySelectorAll('.opt');
  opts.forEach(el => {
    const i = Number(el.dataset.i);
    el.classList.toggle('sel', i === chimeMode);
  });

  chSel.title = 'Finish sound: ' + CHIME_NAMES[chimeMode];
}

function setChimeMode(m, announce=false){
  chimeMode = clamp(Math.round(m), 0, CHIME_COUNT - 1);

  // Warm load birds when selected (BIRDS is index 4 now)
  if (chimeMode === 4) ensureBirdBuffersLoaded();

  updateChimeUI();

  if (announce){
    const h = document.getElementById('hint');
    h.textContent = 'finish sound: ' + CHIME_NAMES[chimeMode].toLowerCase();
    setTimeout(setHint, 900);
  }
}

// Drag math helper
function chimeIndexFromClientX(clientX){
  const r = chSel.getBoundingClientRect();
  const x = clamp(clientX - r.left - 3, 0, r.width - 6); // content width
  const segW = (r.width - 6) / CHIME_COUNT;
  return x / segW; // float index 0..(count-1)
}

// Pointer-only interactions (smooth + click-to-snap)
let chDrag = false;
let chPid = null;
let chStartX = 0;
let chMoved = false;

chSel.addEventListener('pointerdown', (e)=>{
  if (e.pointerType === 'mouse' && e.button !== 0) return;

  // unlock audio early so alarms can play later even if ticking is muted
  try{ ensureAudio(); audioCtx.resume(); }catch(_){}

  chDrag = true;
  chPid = e.pointerId;
  chStartX = e.clientX;
  chMoved = false;

  chSel.classList.add('dragging');
  try{ chSel.setPointerCapture(chPid); }catch(err){}

  // If user pressed directly on an option label, snap immediately
  const opt = e.target?.closest?.('.opt');
  if (opt){
    setChimeMode(Number(opt.dataset.i), true);
    return;
  }

  // Otherwise begin smooth drag
  updateChimeUI(chimeIndexFromClientX(e.clientX));
});

chSel.addEventListener('pointermove', (e)=>{
  if (!chDrag || e.pointerId !== chPid) return;

  if (Math.abs(e.clientX - chStartX) > 3) chMoved = true;

  updateChimeUI(chimeIndexFromClientX(e.clientX));
});

const chUp = (e)=>{
  if (!chDrag || e.pointerId !== chPid) return;

  chDrag = false;
  chSel.classList.remove('dragging');
  try{ chSel.releasePointerCapture(chPid); }catch(err){}
  chPid = null;

  // Always snap to nearest segment on release
  setChimeMode(chimeIndexFromClientX(e.clientX), true);
};

chSel.addEventListener('pointerup', chUp);
chSel.addEventListener('pointercancel', chUp);
chSel.addEventListener('lostpointercapture', ()=>{
  chDrag = false;
  chSel.classList.remove('dragging');
  chPid = null;
  updateChimeUI();
});

// initialize UI
setChimeMode(chimeMode);


  // pointer interactions
  let pointerId = null;
  let lastPressTime = 0;

  function updateFromPointer(x,y){
    const now = performance.now();

    const aNow = pointerAngle(x,y);
    const step = signedAngleDelta(dragLastAngle, aNow);
    dragLastAngle = aNow;

    // Accumulate unwrapped rotation (prevents 30-min cap)
    dragAccum += step;

    // Map accumulated CLOCKWISE rotation to minutes.
    // In CCW-positive angle space: clockwise is negative, so invert sign.
    const deltaMin = (-dragAccum / TAU) * MAX_MIN;
    dialArcMinTargetRaw = clamp(dragStartMin + deltaMin, 0, MAX_MIN);

    // Mark active movement (used to decide when to "loosen" coupling for throw)
    lastPointerMove = now;

    // Estimate drag velocity (minutes/second) for subtle momentum on release
    const dt = Math.max(0.001, (now - lastDragT) / 1000);
    const instVel = (-step / TAU) * MAX_MIN / dt;
    dragVelMinPerSec = dragVelMinPerSec * 0.78 + instVel * 0.22;
    lastDragT = now;
  }

  function onDown(e){
    if (e.pointerType === 'mouse' && e.button !== 0) return;
    if (pointerId !== null) return;
    const x=e.clientX, y=e.clientY;

    if (withinKnob(x,y)){
      knobDown = true;
      // If alarm is ringing, the knob is the "stop".
      if (alarmActive){
        stopAlarm();
        lastPressTime = 0;
        return;
      }

      const t = performance.now();
      if (t - lastPressTime < 320){ startReset(); lastPressTime = 0; return; }
      lastPressTime = t;
      toggleRun();
      return;
    }

    if (withinRing(x,y)){
      // Wind / adjust time (drag)
      dragging = true;
      canvas.style.cursor = 'grabbing';
      pointerId = e.pointerId;
      try{ canvas.setPointerCapture(pointerId); }catch(e){}
      dragStartMin = dialArcMinTarget;
      dragAccum = 0;
      dragLastAngle = pointerAngle(x,y);
      dragVelMinPerSec = 0;
      dialTargetVel = 0;
      dialArcMinTargetRaw = dialArcMinTarget;
      lastDragT = performance.now();
      commitPending = false;
      // If not running, we'll auto-start when the dial settles (analog behavior).
      // If already running, keep running and just adjust remaining time.
      autoStartPending = !running;
      dialVel = 0;
      updateFromPointer(x,y);
      setHint();
    }
  }

  function onMove(e){
    if (!dragging || e.pointerId !== pointerId) return;
    updateFromPointer(e.clientX,e.clientY);
  }

  function onUp(e){
    knobDown = false;
    if (!dragging || e.pointerId !== pointerId) return;
    dragging = false;
    try{ canvas.releasePointerCapture(pointerId); }catch(e){}
    pointerId = null;
    canvas.style.cursor = 'grab';

    // On release: let it coast with subtle momentum, then commit after it settles.
    // Transfer the "throw" into the dial motion on release.
    // Use the inertial target velocity (feels more like a physical dial).
    dialVel = clamp((dialTargetVel || dragVelMinPerSec) * 0.52, -34, 34);
    dialTargetVel *= 0.92;
    commitPending = true;
    commitDeadline = performance.now() + 320;
    autoStartPending = !running;
    setHint();
  }

  // Pointer events: bind to the CANVAS so mouse drag always works reliably.
  canvas.style.cursor = 'grab';
  canvas.addEventListener('pointerdown', onDown);
  canvas.addEventListener('pointermove', onMove);
  canvas.addEventListener('pointerup', onUp);
  canvas.addEventListener('pointercancel', onUp);
  canvas.addEventListener('lostpointercapture', () => {
    if (dragging){
      dragging = false;
      pointerId = null;
      canvas.style.cursor = 'grab';
      commitPending = true;
      commitDeadline = performance.now() + 260;
      autoStartPending = true;
      setHint();
    }
  });

  // âœ… Ensure knob always visually releases even if pointerup happens off-canvas
window.addEventListener('pointerup', () => { knobDown = false; }, { passive:true });
window.addEventListener('pointercancel', () => { knobDown = false; }, { passive:true });
window.addEventListener('blur', () => { knobDown = false; });

  // Trackpad / mouse wheel control â€” smooth like dragging
  // Strategy: treat wheel deltas as an "impulse" that nudges the target, then let the spring
  // in the main animation loop do the smoothing. No snapping, no hard-stop feeling.
  let wheelImpulse = 0;      // minutes to apply (accumulated) â€” used for mouse wheel / non-precise scrolling
  let wheelActiveUntil = 0;  // timestamp (ms) to keep hint state "winding"
  let wheelPrecisionUntil = 0; // when > now, trackpad mode (precise, no momentum)

 function onWheel(e){
  e.preventDefault();

  const now = performance.now();

  // Heuristic: trackpads emit many small deltas (deltaMode 0, small magnitude).
  const isTrackpad = (e.deltaMode === 0 && Math.abs(e.deltaY) < 12);

  const modeScale = (e.deltaMode === 1) ? 16 : (e.deltaMode === 2 ? 240 : 1);
  const dy = e.deltaY * modeScale;

  // Shift = fine control (keep your feel)
  const sensitivity = e.shiftKey ? 0.0045 : 0.010; // minutes per pixel
  const rawDeltaMin = (-dy) * sensitivity;

  const step = 0.5; // 0.5 min = 30 seconds

  if (isTrackpad){
    // âœ… Precise: apply directly and kill any stored momentum.
    wheelImpulse = 0;
    dialTargetVel = 0;
    dialVel *= 0.15;

    // initialize raw target from current snapped target (prevents first-scroll jump)
    dialArcMinTargetRaw = dialArcMinTargetRaw || dialArcMinTarget;

    // accumulate smoothly
    dialArcMinTargetRaw = clamp(dialArcMinTargetRaw + rawDeltaMin, 0, MAX_MIN);

    // snap visible target to 30-second steps
    dialArcMinTarget = clamp(Math.round(dialArcMinTargetRaw / step) * step, 0, MAX_MIN);

    wheelActiveUntil = now + 140;
    wheelPrecisionUntil = now + 320;

    commitPending = true;
    commitDeadline = now + 260;
    autoStartPending = !running;

  } else {
    // âœ… Coarse: keep your physical wheel impulse feel, but snap the target
    wheelImpulse += rawDeltaMin;
    wheelActiveUntil = now + 220;

    const immediate = wheelImpulse * 0.35;

    // initialize raw target from current snapped target
    dialArcMinTargetRaw = dialArcMinTargetRaw || dialArcMinTarget;

    dialArcMinTargetRaw = clamp(dialArcMinTargetRaw + immediate, 0, MAX_MIN);
    dialArcMinTarget = clamp(Math.round(dialArcMinTargetRaw / step) * step, 0, MAX_MIN);

    wheelImpulse -= immediate;

    commitPending = true;
    commitDeadline = now + 520;
    autoStartPending = !running;
  }

  setHint();
}


  canvas.addEventListener('wheel', onWheel, { passive: false });

  // Gold texture (shiny, minimal)
  const goldTex = document.createElement('canvas');
  goldTex.width = 512; goldTex.height = 512;
  const gt = goldTex.getContext('2d');

  (function makeGold(){
    // Gold texture: same vibe, but make the gradient read stronger.
    const g1 = gt.createLinearGradient(0, 0, goldTex.width, goldTex.height);
    g1.addColorStop(0.00, '#6A4B16');
    g1.addColorStop(0.18, '#C8A24A');
    g1.addColorStop(0.34, '#FFF0B6');
    g1.addColorStop(0.50, '#D4A646');
    g1.addColorStop(0.70, '#8A6A22');
    g1.addColorStop(1.00, '#E7C56B');
    gt.fillStyle = g1;
    gt.fillRect(0,0,goldTex.width,goldTex.height);

    // Specular streak (slightly stronger so it doesn't look flat)
    const g2 = gt.createLinearGradient(0, goldTex.height*0.18, goldTex.width, goldTex.height*0.62);
    g2.addColorStop(0.00, 'rgba(255,255,255,0.00)');
    g2.addColorStop(0.34, 'rgba(255,255,255,0.20)');
    g2.addColorStop(0.45, 'rgba(255,255,255,0.12)');
    g2.addColorStop(0.55, 'rgba(255,255,255,0.00)');
    gt.globalCompositeOperation = 'screen';
    gt.fillStyle = g2;
    gt.fillRect(0,0,goldTex.width,goldTex.height);

    // Fine noise (very subtle)
    gt.globalCompositeOperation = 'overlay';
    const img = gt.createImageData(goldTex.width, goldTex.height);
    for (let i=0;i<img.data.length;i+=4){
      const n = (Math.random()*255)|0;
      img.data[i]=n; img.data[i+1]=n; img.data[i+2]=n; img.data[i+3]=14;
    }
    gt.putImageData(img,0,0);

    gt.globalCompositeOperation = 'source-over';
  })();
  const goldPattern = ctx.createPattern(goldTex, 'repeat');

  function drawDial(remMin, isActive){  
    // Keep hint positioned relative to the knob (below center) regardless of canvas size.
    const knobR_forHint = canvas.width * 0.055;
    shell.style.setProperty('--hintY', knobR_forHint + 'px');

    const w=canvas.width,h=canvas.height;
    const cx=w/2,cy=h/2;

    ctx.clearRect(0,0,w,h);
    ctx.fillStyle=BG; ctx.fillRect(0,0,w,h);

    const outerR=w*0.43;
    const innerR=w*0.19;

    const markR = w * 0.335;  // dashes a bit more inward (more air near border)
   

    const handLen = markR;  // âœ… define once, before goldOuterR uses it


    // Gold should TOUCH the ring but never surpass the ring stroke.
    const ringStroke = w*0.012;
    // The ring stroke is centered on outerR. Keep gold just inside the inner edge of that stroke.
    const goldOuterR = handLen; // gold stops exactly at the hand tip
    const goldInnerR = innerR;                    // open center remains clean
    const knobR=w*0.055;
    

    // boundary
    ctx.beginPath();
    ctx.arc(cx,cy,outerR,0,TAU);
    ctx.strokeStyle='rgba(243,239,230,0.09)';
    ctx.lineWidth=w*0.006;
    ctx.stroke();

    // gold ring sector (remaining time) â€” starts COUNTER-CLOCKWISE from the top
    // It grows behind the hand; the hand sits at the leading edge.
    const arcLen=(clamp(remMin,0,MAX_MIN)/MAX_MIN)*TAU;
    const handAng = angle0 - arcLen; // leading edge

    if (remMin>0){
      ctx.save();
      ctx.beginPath();
      // Outer arc from top going counterclockwise (decreasing angle)
      ctx.arc(cx,cy,goldOuterR, angle0, handAng, true);
      // Inner arc back to start
      ctx.arc(cx,cy,goldInnerR, handAng, angle0, false);
      ctx.closePath();

      // Gold: visible + premium
      ctx.shadowColor = 'rgba(208,171,76,0.28)';
      ctx.shadowBlur  = w*0.014;
      ctx.fillStyle = goldPattern || GOLD_BASE;
      ctx.fill();
      ctx.shadowBlur = 0;

      // Push a bit of the base gold hue without flattening texture
      ctx.save();
      ctx.globalCompositeOperation = 'color';
      ctx.globalAlpha = 0.50;
      ctx.fillStyle = GOLD_BASE;
      ctx.fill();
      ctx.restore();

      // Subtle highlight
      const hx = cx - goldOuterR*0.30;
      const hy = cy - goldOuterR*0.18;
      const hg = ctx.createRadialGradient(hx, hy, goldOuterR*0.05, hx, hy, goldOuterR*0.92);
      hg.addColorStop(0.0, 'rgba(255,255,255,0.26)');
      hg.addColorStop(0.34,'rgba(255,255,255,0.10)');
      hg.addColorStop(1.0, 'rgba(255,255,255,0.00)');
      ctx.globalCompositeOperation = 'screen';
      ctx.fillStyle = hg;
      ctx.fill();
      ctx.globalCompositeOperation = 'source-over';

      // Extra overlay gradient to make the gold gradient read clearly
      ctx.save();
      const gg = ctx.createLinearGradient(cx - goldOuterR, cy - goldOuterR, cx + goldOuterR, cy + goldOuterR);
      gg.addColorStop(0.0, 'rgba(255,255,255,0.00)');
      gg.addColorStop(0.36,'rgba(255,255,255,0.12)');
      gg.addColorStop(0.64,'rgba(0,0,0,0.10)');
      gg.addColorStop(1.0, 'rgba(0,0,0,0.00)');
      ctx.globalCompositeOperation = 'overlay';
      ctx.fillStyle = gg;
      ctx.fill();
      ctx.restore();
      ctx.restore();
    }

// Hand (Newgate-like: sharp dauphine + slim seconds)
{
  const a = (remMin > 0) ? handAng : angle0;

  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(a + Math.PI/2); // points "up"

  const baseY     = -innerR * 0.34;
  const tipY      = -handLen;

  // proportions similar to the reference
  const baseW     = w * 0.030;
  const midW      = w * 0.018;
  const tipW      = w * 0.006;
  const midY      = tipY * 0.58;

  // Soft shadow for depth (reads like real metal)
  ctx.shadowColor = 'rgba(0,0,0,0.35)';
  ctx.shadowBlur  = w * 0.010;
  ctx.shadowOffsetY = w * 0.004;

  // Main dauphine body (sharp, faceted)
  ctx.beginPath();
  ctx.moveTo(-baseW*0.5, baseY);
  ctx.lineTo(-midW*0.5,  midY);
  ctx.lineTo(-tipW*0.5,  tipY);
  ctx.lineTo( tipW*0.5,  tipY);
  ctx.lineTo( midW*0.5,  midY);
  ctx.lineTo( baseW*0.5, baseY);
  ctx.closePath();

  ctx.fillStyle = GOLD_BASE;
  ctx.fill();

  // Facet highlight (one side brighter like polished metal)
  ctx.shadowBlur = 0;
  ctx.shadowOffsetY = 0;
  ctx.save();
  ctx.globalCompositeOperation = 'screen';
  ctx.globalAlpha = 0.28;
  ctx.beginPath();
  ctx.moveTo(0, baseY);
  ctx.lineTo(0, tipY);
  ctx.lineTo(-midW*0.52, midY);
  ctx.closePath();
  ctx.fillStyle = 'rgba(255,255,255,1)';
  ctx.fill();
  ctx.restore();

  // Slim seconds hand (very thin, understated)
  ctx.beginPath();
  ctx.moveTo(0, w * 0.020);
  ctx.lineTo(0, -outerR * 0.76);
  ctx.strokeStyle = 'rgba(243,239,230,0.10)'; // softer
  ctx.lineWidth = w*0.00016;                      // thinner
  ctx.lineCap = 'round';
  ctx.stroke();

  // Remove any previous deco tip/cap blocks from your old hand â€” this replaces them.

  ctx.restore();
}

    // minute marks â€” subtle elegant dashes
ctx.save();
ctx.translate(cx,cy);

for (let m=0; m<60; m++){
  const a = angle0 + (m/60)*TAU;

  const big = (m % 5 === 0);
  const dashLen = big ? w*0.014 : w*0.008;     // length of dash
  const dashW   = big ? w*0.0022 : w*0.0016;   // stroke thickness

  // radial dash (points toward center)
  const r2 = markR;           // outer end
  const r1 = markR - dashLen; // inner end

  ctx.beginPath();
  ctx.moveTo(Math.cos(a)*r1, Math.sin(a)*r1);
  ctx.lineTo(Math.cos(a)*r2, Math.sin(a)*r2);

  ctx.strokeStyle = big ? 'rgba(243,239,230,0.58)' : 'rgba(243,239,230,0.34)';
  ctx.lineWidth = dashW;
  ctx.lineCap = 'round';
  ctx.stroke();
}

ctx.restore();


    // numerals (reverse scale: 55 sits where 5 normally is; runs clockwise)
    const marks = [];
    for (let m=0;m<60;m+=5){
      // label is reversed: label = (60 - m) % 60, with 0 shown as 0
      const lab = (60 - m) % 60;
      marks.push({ t: String(lab === 0 ? 0 : lab), m });
    }

    ctx.save();
    ctx.translate(cx,cy);
    ctx.fillStyle=FG;
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    ctx.font=`${Math.round(w*0.050)}px "Neue Einstellung", "Helvetica Neue", Helvetica, Arial, sans-serif`;
    const nr = markR + w*0.040;

    for (const n of marks){
      const a=angle0+(n.m/60)*TAU; // clockwise in screen coords
      ctx.fillText(n.t, Math.cos(a)*nr, Math.sin(a)*nr);
    }
    ctx.restore();

// --- Knob: Art Deco 4-spike diamond bezel + round push button ---
ctx.save();
ctx.translate(cx, cy);

const pressed = !!knobDown;
const k = knobR; // your existing knob radius baseline

// Geometry for the bezel (4 spikes: up/right/down/left)
const tip   = k * 1.55;   // spike length
const shoulder = k * 1.05; // where spikes widen into the bezel
const body  = k * 1.08;   // main body radius
const inner = k * 0.78;   // inner â€œseatâ€ around the button

// Bezel shadow (changes slightly when pressed)
ctx.save();
ctx.shadowColor = 'rgba(0,0,0,0.45)';
ctx.shadowBlur  = w * (pressed ? 0.010 : 0.018);
ctx.shadowOffsetY = w * (pressed ? 0.002 : 0.006);

// Outer bezel shape (4-point diamond: up/right/down/left)
ctx.beginPath();
ctx.moveTo(0, -tip);   // up
ctx.lineTo(tip, 0);    // right
ctx.lineTo(0, tip);    // down
ctx.lineTo(-tip, 0);   // left
ctx.closePath();

// Brass-like fill (simple gradient, looks â€œmachinedâ€)
const brass = ctx.createLinearGradient(-tip, -tip, tip, tip);
brass.addColorStop(0.00, '#6A4B16');
brass.addColorStop(0.22, '#C8A24A');
brass.addColorStop(0.42, '#FFF0B6');
brass.addColorStop(0.62, '#D4A646');
brass.addColorStop(0.82, '#8A6A22');
brass.addColorStop(1.00, '#E7C56B');

ctx.fillStyle = brass;
ctx.fill();

// Edge line (crisp Art Deco border)
ctx.shadowBlur = 0;
ctx.shadowOffsetY = 0;
ctx.strokeStyle = 'rgba(0,0,0,0.28)';
ctx.lineWidth = w * 0.006;
ctx.stroke();

// Inner step (gives the â€œpressed plateâ€ look)
ctx.beginPath();
ctx.moveTo(0, -body);
ctx.lineTo( inner, -inner);
ctx.lineTo( body, 0);
ctx.lineTo( inner, inner);
ctx.lineTo(0, body);
ctx.lineTo(-inner, inner);
ctx.lineTo(-body, 0);
ctx.lineTo(-inner, -inner);
ctx.closePath();

ctx.globalCompositeOperation = 'overlay';
ctx.fillStyle = 'rgba(255,255,255,0.10)';
ctx.fill();
ctx.globalCompositeOperation = 'source-over';
ctx.restore();

// Round button (2 states)
const btnR = k * 0.64;

// When pressed, the button sits â€œlowerâ€
const pressY = pressed ? (w * 0.006) : 0;

// Button shadow (less when pressed)
ctx.shadowColor = 'rgba(0,0,0,0.38)';
ctx.shadowBlur  = w * (pressed ? 0.008 : 0.016);
ctx.shadowOffsetY = w * (pressed ? 0.002 : 0.006);

ctx.beginPath();
ctx.arc(0, pressY, btnR, 0, TAU);

// Slightly warm ivory face (matches your UI)
const face = ctx.createRadialGradient(
  -btnR*0.25, -btnR*0.30 + pressY, btnR*0.10,
   0,          pressY,            btnR*1.05
);
face.addColorStop(0.00, 'rgba(255,255,255,0.78)');
face.addColorStop(0.45, 'rgba(243,239,230,0.94)');
face.addColorStop(1.00, 'rgba(210,205,195,0.95)');
ctx.fillStyle = face;
ctx.fill();

// Button rim
ctx.shadowBlur = 0;
ctx.shadowOffsetY = 0;
ctx.strokeStyle = 'rgba(0,0,0,0.22)';
ctx.lineWidth = w * 0.006;
ctx.stroke();

// Gold center cap (ties to your hand)
ctx.beginPath();
ctx.arc(0, pressY, btnR*0.28, 0, TAU);
ctx.fillStyle = 'rgba(208,171,76,0.95)';
ctx.fill();

// Tiny highlight
ctx.beginPath();
ctx.arc(-btnR*0.12, pressY - btnR*0.14, btnR*0.10, 0, TAU);
ctx.fillStyle = 'rgba(255,255,255,0.25)';
ctx.fill();

// Optional: subtle â€œPRESSâ€ mark? (commented so you can decide)
// ctx.font = `700 ${Math.round(w*0.022)}px system-ui, Arial`;
// ctx.fillStyle = 'rgba(11,11,13,0.35)';
// ctx.textAlign='center'; ctx.textBaseline='middle';
// ctx.fillText('PRESS', 0, pressY + btnR*0.02);

ctx.restore();


ctx.restore();


    if (isActive){
      ctx.fillStyle='rgba(255,255,255,0.03)';
      ctx.fillRect(0,0,w,h);
    }
  }

  function frame(t){
    const dt = Math.min(0.05, (t-lastFrame)/1000);
    lastFrame = t;

    const now = performance.now();

    // Mechanical reset animation (rewind)
    if (resetting){
      // Pull target to zero with a stiffer spring and controlled damping.
      dialArcMinTarget = 0;

      const kR = 180;   // strong spring
      const cR = 26;    // heavy damping
      const accR = kR*(dialArcMinTarget - dialArcMin) - cR*dialVel;
      dialVel += accR*dt;
      dialArcMin = clamp(dialArcMin + dialVel*dt, 0, MAX_MIN);

      totalSec = Math.round(dialArcMin*60);
      remainingSec = totalSec;

      // Finish when it's effectively at zero
      if (dialArcMin <= 0.02 && Math.abs(dialVel) < 0.25){
        resetAll();
        // IMPORTANT: keep the animation loop alive after reset.
        drawDial(0, false);
        requestAnimationFrame(frame);
      } else {
        drawDial(dialArcMin, false);
        requestAnimationFrame(frame);
      }
      return;
    }
    const wheelWinding = now < wheelActiveUntil;
    const interacting = dragging || wheelWinding || commitPending;

    // Apply wheel impulse gradually so it never "hits" a stop.
    if (wheelImpulse !== 0){
      const take = wheelImpulse * Math.min(1, dt * 18);
      dialArcMinTarget = clamp(dialArcMinTarget + take, 0, MAX_MIN);
      wheelImpulse -= take;
      if (Math.abs(wheelImpulse) < 0.0005) wheelImpulse = 0;
    }

    // If user is winding/adjusting OR timer isn't running yet:
    // dial physics controls the time value. This gives the "mechanical" feel.
    if (interacting || !running){
      // While dragging: give the TARGET inertia so the dial can be "thrown" (no hard stop).
      // The key is to NOT glue the target to the pointer when the pointer stops moving.
      if (dragging){
        const sinceMove = now - lastPointerMove;

        // Smooth the target velocity toward the user's drag velocity
        dialTargetVel += (dragVelMinPerSec - dialTargetVel) * Math.min(1, dt*16);

        // Friction on target motion (slower than before so it can coast)
        dialTargetVel *= Math.exp(-dt*2.8);

        // Integrate inertial target
        dialArcMinTarget += dialTargetVel * dt;

        // Coupling to the pointer: strong while the pointer is actively moving,
        // weaker when the pointer is held still (this is what creates "throw" during drag).
        const coupleRate = (sinceMove < 90) ? 18 : 2.8;
        const pull = 1 - Math.exp(-dt*coupleRate);
        dialArcMinTarget += (dialArcMinTargetRaw - dialArcMinTarget) * pull;

        // Clamp target and kill velocity into the stops (no bounce)
        if (dialArcMinTarget <= 0){ dialArcMinTarget = 0; if (dialTargetVel < 0) dialTargetVel = 0; }
        if (dialArcMinTarget >= MAX_MIN){ dialArcMinTarget = MAX_MIN; if (dialTargetVel > 0) dialTargetVel = 0; }
      }

      // Extra damping for trackpad precision so it stops cleanly (no coast).
      const precision = (!dragging && now < wheelPrecisionUntil);
      const k = dragging ? 110 : (precision ? 160 : 90);
      const c = dragging ? 14  : (precision ? 44  : 20);

      const acc = k*(dialArcMinTarget - dialArcMin) - c*dialVel;
      dialVel += acc*dt;

      // Feed-forward drag velocity into the dial body (keeps it lively)
      if (dragging){
        dialVel += (dragVelMinPerSec*0.40 - dialVel) * 0.18;
      }

      dialArcMin = clamp(dialArcMin + dialVel*dt, 0, MAX_MIN);

      // While winding, reflect dial into time immediately.
      const secs = Math.round(dialArcMin * 60);
      totalSec = secs;
      remainingSec = secs;

     } else {
  // âœ… Normal countdown based on real elapsed time (survives hidden tabs/minimize)
  const elapsed = (performance.now() - runStartT) / 1000;
  remainingSec = Math.max(0, runStartRemaining - elapsed);

  if (remainingSec <= 0){
    onTimerFinished();   // âœ… single source of truth (RAF + background watcher)
  }

  dialArcMin = remainingSec/60;
  dialArcMinTarget = dialArcMin;
  dialVel = 0;
}



    // Commit once the dial has settled (prevents snapping on release)
    // Works both for "start after wind" and "adjust while running".
    if (!dragging && commitPending){
      const settled = Math.abs(dialVel) < 0.08 && Math.abs(dialArcMinTarget - dialArcMin) < 0.08;
      if (settled || now > commitDeadline){
        dialArcMin = clamp(dialArcMin, 0, MAX_MIN);
        dialArcMinTarget = dialArcMin;
        dialVel = 0;

        commitDial();
        commitPending = false;

        if (!running && autoStartPending && remainingSec > 0){
          running = true;

          // âœ… anchor countdown at the moment it starts
          runStartT = performance.now();
          runStartRemaining = remainingSec;

          startTicking();
          startFinishWatch();

        }


        autoStartPending = false;
        setHint();
      }
    }

    drawDial(dialArcMin, running);
    requestAnimationFrame(frame);
  }

  setHint();

  // --- tiny runtime self-tests (dev-only safety net) ---
  (function selfTest(){
    try{
      console.assert(canvas && ctx, '[GILT] canvas/context missing');
      console.assert(Number.isFinite(MAX_MIN) && MAX_MIN === 60, '[GILT] MAX_MIN mismatch');
      console.assert(typeof onWheel === 'function', '[GILT] onWheel missing');
      console.assert(typeof drawDial === 'function', '[GILT] drawDial missing');
      console.assert(typeof startReset === 'function', '[GILT] startReset missing');
      console.assert(typeof dialArcMinTargetRaw !== 'undefined', '[GILT] dialArcMinTargetRaw missing');
    } catch(e){
      console.warn('[GILT] selfTest warning:', e);
    }
  })();

  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
